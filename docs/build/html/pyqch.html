<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>pyqch package &#8212; PyQch 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=12dfc556" />
    <script src="_static/documentation_options.js?v=01f34227"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="pyqch" href="modules.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="pyqch-package">
<h1>pyqch package<a class="headerlink" href="#pyqch-package" title="Link to this heading">¶</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading">¶</a></h2>
</section>
<section id="module-pyqch.base_change_unitaries">
<span id="pyqch-base-change-unitaries-module"></span><h2>pyqch.base_change_unitaries module<a class="headerlink" href="#module-pyqch.base_change_unitaries" title="Link to this heading">¶</a></h2>
<section id="base-change-unitaries">
<h3>base_change_unitaries<a class="headerlink" href="#base-change-unitaries" title="Link to this heading">¶</a></h3>
<p>This module implements functions that return unitaries for transforming
density matrices between different bases. It currently includes transformations
related to the generalized Gell-Mann basis and the element-wise (computational
or canonical) basis, with potential for future extensions to other transformations.</p>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="pyqch.base_change_unitaries.el_gm">
<span class="sig-prename descclassname"><span class="pre">pyqch.base_change_unitaries.</span></span><span class="sig-name descname"><span class="pre">el_gm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.base_change_unitaries.el_gm" title="Link to this definition">¶</a></dt>
<dd><p>Returns the unitary matrix that transforms from the element-wise
(computational) basis to the coefficients in the generalized
Gell-Mann normalized basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dim</strong> (<em>int</em>) – The dimension of the Hilbert space.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The unitary matrix for the basis transformation.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#pyqch.base_change_unitaries.gm_el" title="pyqch.base_change_unitaries.gm_el"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gm_el</span></code></a></dt><dd><p>Returns the inverse transformation.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">base_change_unitaries</span> <span class="kn">import</span> <span class="n">el_gm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dim</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">U_el_gm</span> <span class="o">=</span> <span class="n">gm_el</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Define a density matrix in the computational basis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Transform the density matrix to the Gell-Mann basis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho_gm</span> <span class="o">=</span> <span class="n">U_el_gm</span> <span class="o">@</span> <span class="n">rho</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dim</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;rho in Gell-Mann basis:&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rho_gm</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.base_change_unitaries.gm_el">
<span class="sig-prename descclassname"><span class="pre">pyqch.base_change_unitaries.</span></span><span class="sig-name descname"><span class="pre">gm_el</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.base_change_unitaries.gm_el" title="Link to this definition">¶</a></dt>
<dd><p>Returns the unitary matrix that transforms from the coefficients in the
generalized Gell-Mann normalized basis to the element-wise (computational) basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dim</strong> (<em>int</em>) – The dimension of the Hilbert space.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The unitary matrix for the basis transformation.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#pyqch.base_change_unitaries.el_gm" title="pyqch.base_change_unitaries.el_gm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">el_gm</span></code></a></dt><dd><p>Returns the inverse transformation.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Gell-Mann matrices are a generalization of the Pauli matrices used to
describe higher-dimensional systems in quantum mechanics <a class="footnote-reference brackets" href="#id2" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. They form a
complete, orthogonal basis for the space of Hermitian matrices.</p>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Gell-Mann_matrices">https://en.wikipedia.org/wiki/Gell-Mann_matrices</a></p>
</aside>
</aside>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">base_change_unitaries</span> <span class="kn">import</span> <span class="n">gm_el</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">U_el_gm</span> <span class="o">=</span> <span class="n">el_gm</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># Transforms from the normalized Pauli basis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Define a density matrix in the Pauli basis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho_pauli</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Transform the density matrix to the element-wise basis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span> <span class="o">=</span> <span class="p">(</span><span class="n">U_el_gm</span> <span class="o">@</span> <span class="n">rho_pauli</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;rho in element-wise basis:&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
<span class="go">[[ 0.5  0.5 ]</span>
<span class="go"> [ 0.5  0.5 ]]</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-pyqch.channel_families">
<span id="pyqch-channel-families-module"></span><h2>pyqch.channel_families module<a class="headerlink" href="#module-pyqch.channel_families" title="Link to this heading">¶</a></h2>
<section id="channel-families">
<h3>channel_families<a class="headerlink" href="#channel-families" title="Link to this heading">¶</a></h3>
<p>This module implements functions that return the transition matrices
describing different families of quantum channels. These functions
cover a variety of quantum operations including classical permutations,
dephasing, depolarizing, embedding classical channels, initializers,
POVMs, probabilistic damping, and probabilistic unitaries.</p>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="pyqch.channel_families.classical_permutation">
<span class="sig-prename descclassname"><span class="pre">pyqch.channel_families.</span></span><span class="sig-name descname"><span class="pre">classical_permutation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">perm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.channel_families.classical_permutation" title="Link to this definition">¶</a></dt>
<dd><p>Returns the transition matrix representing a classical permutation
channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of the Hilbert space.</p></li>
<li><p><strong>perm</strong> (<em>list</em>) – The array defining the permutation that maps i to perm[i].</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transition matrix representing the classical permutation channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_families</span> <span class="kn">import</span> <span class="n">classical_permutation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">perm</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">classical_permutation</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">[[0. 1. 0.]</span>
<span class="go"> [0. 0. 1.]</span>
<span class="go"> [1. 0. 0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.channel_families.dephasing">
<span class="sig-prename descclassname"><span class="pre">pyqch.channel_families.</span></span><span class="sig-name descname"><span class="pre">dephasing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.channel_families.dephasing" title="Link to this definition">¶</a></dt>
<dd><p>Returns the transition matrix for a dephasing channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of the Hilbert space.</p></li>
<li><p><strong>g</strong> (<em>float</em>) – Dephasing strength.</p></li>
<li><p><strong>u</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – The unitary matrix defining the basis in which dephasing occurs.
Defaults to the identity matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transition matrix for the dephasing channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function implements dephasing by dampening the off-diagonal terms
in a given basis. For generalized dephasing, one should define the
corresponding PVMs and include an identity with some dampening, then
pass them to the <cite>povm</cite> function.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_families</span> <span class="kn">import</span> <span class="n">dephasing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dim</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">dephasing</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">[[1. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ],</span>
<span class="go">   [0. , 0.5, 0. , 0. , 0. , 0. , 0. , 0. , 0. ],</span>
<span class="go">   [0. , 0. , 0.5, 0. , 0. , 0. , 0. , 0. , 0. ],</span>
<span class="go">   [0. , 0. , 0. , 0.5, 0. , 0. , 0. , 0. , 0. ],</span>
<span class="go">   [0. , 0. , 0. , 0. , 1. , 0. , 0. , 0. , 0. ],</span>
<span class="go">   [0. , 0. , 0. , 0. , 0. , 0.5, 0. , 0. , 0. ],</span>
<span class="go">   [0. , 0. , 0. , 0. , 0. , 0. , 0.5, 0. , 0. ],</span>
<span class="go">   [0. , 0. , 0. , 0. , 0. , 0. , 0. , 0.5, 0. ],</span>
<span class="go">   [0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 1. ]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.channel_families.depolarizing">
<span class="sig-prename descclassname"><span class="pre">pyqch.channel_families.</span></span><span class="sig-name descname"><span class="pre">depolarizing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.channel_families.depolarizing" title="Link to this definition">¶</a></dt>
<dd><p>Returns the transition matrix for a depolarizing channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of the Hilbert space.</p></li>
<li><p><strong>p</strong> (<em>float</em>) – Depolarizing probability.</p></li>
<li><p><strong>r</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – The stationary state of the depolarizing channel. Defaults to the
completely mixed state.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transition matrix for the depolarizing channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_families</span> <span class="kn">import</span> <span class="n">depolarizing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dim</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">depolarizing</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho_out</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span> <span class="o">@</span> <span class="n">rho_in</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dim</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rho_out</span><span class="p">)</span>
<span class="go">[[0.86666667+0.j 0.        +0.j 0.        +0.j]</span>
<span class="go"> [0.        +0.j 0.06666667+0.j 0.        +0.j]</span>
<span class="go"> [0.        +0.j 0.        +0.j 0.06666667+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.channel_families.embed_classical">
<span class="sig-prename descclassname"><span class="pre">pyqch.channel_families.</span></span><span class="sig-name descname"><span class="pre">embed_classical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stoch_mat</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.channel_families.embed_classical" title="Link to this definition">¶</a></dt>
<dd><p>Embeds a classical stochastic matrix into a quantum transition matrix.</p>
<p>The resulting process sets off-diagonal terms to zero and acts on the diagonal
terms following the classical stochastic process.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of the Hilbert space.</p></li>
<li><p><strong>stoch_mat</strong> (<em>np.ndarray</em>) – The classical column-stochastic matrix to be embedded.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transition matrix representing the embedded classical channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_families</span> <span class="kn">import</span> <span class="n">embed_classical</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stoch_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">embed_classical</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">stoch_mat</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">[[0.8 0.  0.  0.3]</span>
<span class="go"> [0.  0.  0.  0. ]</span>
<span class="go"> [0.  0.  0.  0. ]</span>
<span class="go"> [0.2 0.  0.  0.7]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.channel_families.initializer">
<span class="sig-prename descclassname"><span class="pre">pyqch.channel_families.</span></span><span class="sig-name descname"><span class="pre">initializer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'c-q'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.channel_families.initializer" title="Link to this definition">¶</a></dt>
<dd><p>Returns a transition matrix for initializing a quantum state.</p>
<p>The initializer channel takes a classical probability distribution as
input and produces a density matrix.</p>
<p>The <cite>mode</cite> argument defines the format of the input and output states.
The initial state can be a classical array (c) or a density matrix whose
diagonal elements are used as the input probability distribution (q),
discarding off-diagonal terms. The output state can store only the
initialized states (q) or also the input probability distribution (qc)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of the Hilbert space.</p></li>
<li><p><strong>states</strong> (<em>np.ndarray</em>) – Array of states defining the choices for initialization.
The expected shape is (number of states, dim, dim), such that
states[i] represents the state prepared when the classical
variable takes the value i.</p></li>
<li><p><strong>mode</strong> (<em>str</em><em>, </em><em>optional</em>) – Mode of initialization (‘c-q’ for classical to quantum,
‘c-qc’ for classical to quantum and classical, ‘q-q’ for
quantum to quantum, ‘q-qc’ for quantum to quantum and
classical). Defaults to ‘c-q’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transition matrix for the initializer.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_families</span> <span class="kn">import</span> <span class="n">initializer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
<span class="go">                        [[.5, .5], [.5, .5]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">initializer</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">states</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">[[1.  0.5]</span>
<span class="go"> [0.  0.5]</span>
<span class="go"> [0.  0.5]</span>
<span class="go"> [0.  0.5]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.channel_families.povm">
<span class="sig-prename descclassname"><span class="pre">pyqch.channel_families.</span></span><span class="sig-name descname"><span class="pre">povm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'q-q'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.channel_families.povm" title="Link to this definition">¶</a></dt>
<dd><p>Returns a transition matrix for a quantum channel defined by a
positive operator-valued measure (POVM).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of the Hilbert space.</p></li>
<li><p><strong>pos</strong> (<em>np.ndarray</em>) – The POVM elements defining the channel. The expected shape is
(number of positive operators, dim, dim), such that pos[i] is
the ith positive operator.</p></li>
<li><p><strong>mode</strong> (<em>str</em><em>, </em><em>optional</em>) – Mode of the channel (‘q-q’ for quantum to quantum,
‘q-c’ for quantum to classical, ‘q-qc’ for quantum to
quantum and classical). Defaults to ‘q-q’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transition matrix for the POVM-based quantum channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_families</span> <span class="kn">import</span> <span class="n">povm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">povm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">[[1 0 0 0]</span>
<span class="go"> [0 0 0 0]</span>
<span class="go"> [0 0 0 0]</span>
<span class="go"> [0 0 0 1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.channel_families.probabilistic_damping">
<span class="sig-prename descclassname"><span class="pre">pyqch.channel_families.</span></span><span class="sig-name descname"><span class="pre">probabilistic_damping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.channel_families.probabilistic_damping" title="Link to this definition">¶</a></dt>
<dd><p>Returns a transition matrix for a probabilistic damping channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of the Hilbert space.</p></li>
<li><p><strong>p</strong> (<em>float</em>) – Damping probability.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transition matrix for the probabilistic damping channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_families</span> <span class="kn">import</span> <span class="n">probabilistic_damping</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">probabilistic_damping</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">[[1.  0.  0.  0.1]</span>
<span class="go"> [0.  0.9 0.  0. ]</span>
<span class="go"> [0.  0.  0.9 0. ]</span>
<span class="go"> [0.  0.  0.  0.9]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.channel_families.probabilistic_unitaries">
<span class="sig-prename descclassname"><span class="pre">pyqch.channel_families.</span></span><span class="sig-name descname"><span class="pre">probabilistic_unitaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_arr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_arr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.channel_families.probabilistic_unitaries" title="Link to this definition">¶</a></dt>
<dd><p>Returns a transition matrix for a channel that applies unitaries
probabilistically.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of the Hilbert space.</p></li>
<li><p><strong>p_arr</strong> (<em>np.ndarray</em>) – Probabilities for each unitary operation.</p></li>
<li><p><strong>u_arr</strong> (<em>np.ndarray</em>) – Array of unitary matrices. The expected shape is
(number of unitaries, dim, dim), such that u_arr[i] is
the ith possible unitary.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transition matrix for the probabilistic unitary channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>This example demonstrates the implementation of a bit-flip channel.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_families</span> <span class="kn">import</span> <span class="n">probabilistic_unitaries</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">probabilistic_unitaries</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">p_arr</span><span class="p">,</span> <span class="n">u_arr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">[[0.5 0.  0.  0.5]</span>
<span class="go"> [0.  0.5 0.5 0. ]</span>
<span class="go"> [0.  0.5 0.5 0. ]</span>
<span class="go"> [0.5 0.  0.  0.5]]</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-pyqch.channel_operations">
<span id="pyqch-channel-operations-module"></span><h2>pyqch.channel_operations module<a class="headerlink" href="#module-pyqch.channel_operations" title="Link to this heading">¶</a></h2>
<section id="channel-operations">
<h3>channel_operations<a class="headerlink" href="#channel-operations" title="Link to this heading">¶</a></h3>
<p>This module implements various operations on quantum channels. It includes
functions for obtaining the Choi state of a channel, performing tensor
products of channel representations, and finding fixed points of a channel.</p>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="pyqch.channel_operations.choi_state">
<span class="sig-prename descclassname"><span class="pre">pyqch.channel_operations.</span></span><span class="sig-name descname"><span class="pre">choi_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.channel_operations.choi_state" title="Link to this definition">¶</a></dt>
<dd><p>Returns the Choi state representation of a given quantum channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>t</strong> (<em>np.ndarray</em>) – The transition matrix representing the quantum channel.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The Choi state corresponding to the quantum channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_operations</span> <span class="kn">import</span> <span class="n">choi_state</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_families</span> <span class="kn">import</span> <span class="n">depolarizing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="mf">.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">depolarizing</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">choi</span> <span class="o">=</span> <span class="n">choi_state</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">choi</span><span class="p">)</span>
<span class="go">[[0.375+0.j 0.   +0.j 0.   +0.j 0.25 +0.j]</span>
<span class="go"> [0.   +0.j 0.125+0.j 0.   +0.j 0.   +0.j]</span>
<span class="go"> [0.   +0.j 0.   +0.j 0.125+0.j 0.   +0.j]</span>
<span class="go"> [0.25 +0.j 0.   +0.j 0.   +0.j 0.375+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.channel_operations.fixed_points">
<span class="sig-prename descclassname"><span class="pre">pyqch.channel_operations.</span></span><span class="sig-name descname"><span class="pre">fixed_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-06</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.channel_operations.fixed_points" title="Link to this definition">¶</a></dt>
<dd><p>Returns the fixed points of a given quantum channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<em>np.ndarray</em>) – The transition matrix representing the quantum channel.</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance for determining fixed points. Defaults to 1e-6.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The fixed points of the quantum channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>NotImplementedError</strong> – If more than one fixed point is detected.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_operations</span> <span class="kn">import</span> <span class="n">fixed_points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_families</span> <span class="kn">import</span> <span class="n">depolarizing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dim</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.3</span><span class="p">,</span> <span class="mf">.2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">depolarizing</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho_ref</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fixed_pt</span> <span class="o">=</span> <span class="n">fixed_points</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">fixed_pt</span><span class="p">,</span> <span class="n">rho_ref</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.channel_operations.tensor">
<span class="sig-prename descclassname"><span class="pre">pyqch.channel_operations.</span></span><span class="sig-name descname"><span class="pre">tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_arr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.channel_operations.tensor" title="Link to this definition">¶</a></dt>
<dd><p>Returns the tensor product of quantum channels represented by their
transition matrices.</p>
<p>This function can be used in two ways:</p>
<ol class="arabic simple">
<li><p>Provide a list of transition matrices to compute their tensor product.</p></li>
<li><p>Provide a single transition matrix and a value for <cite>n</cite> to compute the
self-tensor product applied <cite>n</cite> times.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t_arr</strong> (<em>np.ndarray</em><em> or </em><em>list</em><em> of </em><em>np.ndarray</em>) – A single transition matrix or a list of transition matrices.</p></li>
<li><p><strong>n</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of times to apply the tensor product to a single transition
matrix. Ignored if <cite>t_arr</cite> is a list of matrices. Defaults to 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting tensor product of the transition matrices.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Define a qubit-depolarizing and a qubit identity channel.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_operations</span> <span class="kn">import</span> <span class="n">tensor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_families</span> <span class="kn">import</span> <span class="n">depolarizing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tdepol</span> <span class="o">=</span> <span class="n">depolarizing</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">dim</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Example 1: Tensor product of a list of matrices
Demonstrates how to construct an inhomogeneous local depolarizer that
acts on two qubits, but only adds noise to the state of the first qubit.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tensor_product</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">([</span><span class="n">tdepol</span><span class="p">,</span> <span class="n">tid</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tensor_product</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(16, 16)</span>
</pre></div>
</div>
<p>Example 2: Self-tensor product of a single matrix applied n times
Demostrates how to build a multi-qubit homogeneous depolarizing channel.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">local_depol</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">tdepol</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">local_depol</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64, 64)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-pyqch.divergences">
<span id="pyqch-divergences-module"></span><h2>pyqch.divergences module<a class="headerlink" href="#module-pyqch.divergences" title="Link to this heading">¶</a></h2>
<section id="divergences">
<h3>divergences<a class="headerlink" href="#divergences" title="Link to this heading">¶</a></h3>
<p>This module implements various quantum divergences, which are bivariate functions
that assign a dissimilarity measure to quantum states.</p>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="pyqch.divergences.hockey_stick">
<span class="sig-prename descclassname"><span class="pre">pyqch.divergences.</span></span><span class="sig-name descname"><span class="pre">hockey_stick</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#pyqch.divergences.hockey_stick" title="Link to this definition">¶</a></dt>
<dd><p>Computes the hockey-stick divergence between two quantum states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rho</strong> (<em>np.ndarray</em>) – The first quantum state (density matrix).</p></li>
<li><p><strong>sigma</strong> (<em>np.ndarray</em>) – The second quantum state (density matrix).</p></li>
<li><p><strong>gamma</strong> (<em>float</em>) – The parameter gamma used in the divergence calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The hockey-stick divergence between the two states.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.float64</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gamma</span> <span class="o">=</span> <span class="mf">1.25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">divergence</span> <span class="o">=</span> <span class="n">hockey_stick</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)</span>
<span class="go">0.051776695296636865</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.divergences.hs_dist">
<span class="sig-prename descclassname"><span class="pre">pyqch.divergences.</span></span><span class="sig-name descname"><span class="pre">hs_dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#pyqch.divergences.hs_dist" title="Link to this definition">¶</a></dt>
<dd><p>Computes the Hilbert-Schmidt distance between two quantum states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rho</strong> (<em>np.ndarray</em>) – The first quantum state (density matrix).</p></li>
<li><p><strong>sigma</strong> (<em>np.ndarray</em>) – The second quantum state (density matrix).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The Hilbert-Schmidt distance between the two states.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.float64</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hs_dist</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
<span class="go">0.19999999999999998</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.divergences.max_relative_entropy">
<span class="sig-prename descclassname"><span class="pre">pyqch.divergences.</span></span><span class="sig-name descname"><span class="pre">max_relative_entropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#pyqch.divergences.max_relative_entropy" title="Link to this definition">¶</a></dt>
<dd><p>Computes the max-relative entropy between two quantum states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rho</strong> (<em>np.ndarray</em>) – The first quantum state (density matrix).</p></li>
<li><p><strong>sigma</strong> (<em>np.ndarray</em>) – The second quantum state (density matrix).</p></li>
<li><p><strong>basis</strong> (<em>int</em><em>, </em><em>optional</em>) – The logarithmic base for the entropy calculation. Defaults to 2.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The max-relative entropy between the two states.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.float64</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_relative_entropy</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
<span class="go">0.4796385281957086</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.divergences.relative_entropy">
<span class="sig-prename descclassname"><span class="pre">pyqch.divergences.</span></span><span class="sig-name descname"><span class="pre">relative_entropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#pyqch.divergences.relative_entropy" title="Link to this definition">¶</a></dt>
<dd><p>Computes the relative entropy (Kullback-Leibler divergence) between two quantum states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rho</strong> (<em>np.ndarray</em>) – The first quantum state (density matrix).</p></li>
<li><p><strong>sigma</strong> (<em>np.ndarray</em>) – The second quantum state (density matrix).</p></li>
<li><p><strong>basis</strong> (<em>int</em><em>, </em><em>optional</em>) – The logarithmic base for the entropy calculation. Defaults to 2.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The relative entropy between the two states.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.float64</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropy</span> <span class="o">=</span> <span class="n">relative_entropy</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
<span class="go">0.060147116858855876</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.divergences.tr_dist">
<span class="sig-prename descclassname"><span class="pre">pyqch.divergences.</span></span><span class="sig-name descname"><span class="pre">tr_dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#pyqch.divergences.tr_dist" title="Link to this definition">¶</a></dt>
<dd><p>Computes the trace distance between two quantum states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rho</strong> (<em>np.ndarray</em>) – The first quantum state (density matrix).</p></li>
<li><p><strong>sigma</strong> (<em>np.ndarray</em>) – The second quantum state (density matrix).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The trace distance between the two states.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.float64</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tr_dist</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
<span class="go">0.1414213562373095</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-pyqch.predicates">
<span id="pyqch-predicates-module"></span><h2>pyqch.predicates module<a class="headerlink" href="#module-pyqch.predicates" title="Link to this heading">¶</a></h2>
<section id="predicates">
<h3>predicates<a class="headerlink" href="#predicates" title="Link to this heading">¶</a></h3>
<p>This module contains functions to check whether a given matrix is a density matrix
or a quantum channel.</p>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="pyqch.predicates.is_channel">
<span class="sig-prename descclassname"><span class="pre">pyqch.predicates.</span></span><span class="sig-name descname"><span class="pre">is_channel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pyqch.predicates.is_channel" title="Link to this definition">¶</a></dt>
<dd><p>Checks if the given matrix is a valid quantum channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<em>np.ndarray</em>) – The transition matrix representing the quantum channel.</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance for the numerical checks. Defaults to 1e-6.</p></li>
<li><p><strong>show</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, prints the results of the various tests performed. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the matrix is a valid quantum channel, False otherwise.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">predicates</span> <span class="kn">import</span> <span class="n">is_channel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_families</span> <span class="kn">import</span> <span class="n">depolarizing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dim</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tdepol</span> <span class="o">=</span> <span class="n">depolarizing</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_channel</span><span class="p">(</span><span class="n">tdepol</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="mf">2.5</span> <span class="o">*</span> <span class="n">tdepol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">is_channel</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">show</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">For the Choi matrix of the channel:</span>
<span class="go">Trace diff:  1.4999999999999996</span>
<span class="go">Hermiticity diff:  0.0</span>
<span class="go">Minimum eigval:  0.1388888888888888</span>
<span class="go">Channel is not trace preserving.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.predicates.is_density_matrix">
<span class="sig-prename descclassname"><span class="pre">pyqch.predicates.</span></span><span class="sig-name descname"><span class="pre">is_density_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pyqch.predicates.is_density_matrix" title="Link to this definition">¶</a></dt>
<dd><p>Checks if the given matrix is a valid density matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dm</strong> (<em>np.ndarray</em>) – The matrix to be checked.</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance for the numerical checks. Defaults to 1e-6.</p></li>
<li><p><strong>show</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, prints the results of the various tests performed. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the matrix is a valid density matrix, False otherwise.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">predicates</span> <span class="kn">import</span> <span class="n">is_density_matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">is_density_matrix</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Trace diff:  0.0</span>
<span class="go">Hermiticity diff:  0.0</span>
<span class="go">Minimum eigval:  0.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">is_density_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Trace diff:  0.0</span>
<span class="go">Hermiticity diff:  0.0</span>
<span class="go">Minimum eigval:  -0.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-pyqch.random_generators">
<span id="pyqch-random-generators-module"></span><h2>pyqch.random_generators module<a class="headerlink" href="#module-pyqch.random_generators" title="Link to this heading">¶</a></h2>
<section id="random-generators">
<h3>random_generators<a class="headerlink" href="#random-generators" title="Link to this heading">¶</a></h3>
<p>This module contains functions to generate random quantum channels and states by sampling from various distributions.</p>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="pyqch.random_generators.channel">
<span class="sig-prename descclassname"><span class="pre">pyqch.random_generators.</span></span><span class="sig-name descname"><span class="pre">channel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim_in</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim_out</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kraus_rank</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.random_generators.channel" title="Link to this definition">¶</a></dt>
<dd><p>Generates a random quantum channel by generating a random isometry
(truncated Haar-random unitary) and tracing out the environment.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim_in</strong> (<em>int</em>) – Input dimension of the quantum channel.</p></li>
<li><p><strong>dim_out</strong> (<em>int</em><em>, </em><em>optional</em>) – Output dimension of the quantum channel. If None, defaults to dim_in.</p></li>
<li><p><strong>kraus_rank</strong> (<em>int</em><em>, </em><em>optional</em>) – Rank of the Kraus operators representing the quantum channel. If None, defaults to dim_in * dim_out.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transition matrix representing the random quantum channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">random_generators</span> <span class="kn">import</span> <span class="n">channel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dim_in</span><span class="p">,</span> <span class="n">dim_out</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">channel</span><span class="p">(</span><span class="n">dim_in</span><span class="p">,</span> <span class="n">dim_out</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(9, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.random_generators.state">
<span class="sig-prename descclassname"><span class="pre">pyqch.random_generators.</span></span><span class="sig-name descname"><span class="pre">state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.random_generators.state" title="Link to this definition">¶</a></dt>
<dd><p>Generates a random quantum state by sampling Haar random
pure states on dimension dim * rank and computing the
partiual trace on rank degrees of freedom.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – Dimension of the quantum state.</p></li>
<li><p><strong>rank</strong> (<em>int</em><em>, </em><em>optional</em>) – Rank of the state. If None, defaults to dim.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The random quantum state.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">random_generators</span> <span class="kn">import</span> <span class="n">state</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rank</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span> <span class="o">=</span> <span class="n">state</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
<span class="go">[[ 0.7984795 +3.77722651e-19j -0.21614672+3.37920970e-01j]</span>
<span class="go"> [-0.21614672-3.37920970e-01j  0.2015205 -3.08140272e-18j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.random_generators.state_dirichlet">
<span class="sig-prename descclassname"><span class="pre">pyqch.random_generators.</span></span><span class="sig-name descname"><span class="pre">state_dirichlet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.random_generators.state_dirichlet" title="Link to this definition">¶</a></dt>
<dd><p>Generates random quantum states by sampling their spectrum from the homogeneous Dirichlet distribution
with concentration parameter alpha. The basis are rotated with Haar random unitary matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – Dimension of the quantum state.</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – Concentration parameter of the Dirichlet distribution.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The random quantum state.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As alpha -&gt; 0 generated states are more pure, alpha = 1 is
equivalent to a Hilbert-Schmidt uniform measure, and as
alpha -&gt; infty it concentrates around the maximally mixed
state.</p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">random_generators</span> <span class="kn">import</span> <span class="n">state_dirichlet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span> <span class="o">=</span> <span class="n">state_dirichlet</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
<span class="go">[[ 0.33869694+0.j        -0.24593237-0.4043495j]</span>
<span class="go"> [-0.24593237+0.4043495j  0.66130306+0.j       ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.random_generators.unitary_channel">
<span class="sig-prename descclassname"><span class="pre">pyqch.random_generators.</span></span><span class="sig-name descname"><span class="pre">unitary_channel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.random_generators.unitary_channel" title="Link to this definition">¶</a></dt>
<dd><p>Generates a random unitary quantum channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dim</strong> (<em>int</em>) – Dimension of the Holbert space.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transition matrix representing the random unitary quantum channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">random_generators</span> <span class="kn">import</span> <span class="n">unitary_channel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">U</span> <span class="o">=</span> <span class="n">unitary_channel</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">U</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">U</span> <span class="o">@</span> <span class="n">U</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">dim</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-pyqch.state_families">
<span id="pyqch-state-families-module"></span><h2>pyqch.state_families module<a class="headerlink" href="#module-pyqch.state_families" title="Link to this heading">¶</a></h2>
<section id="state-families">
<h3>state_families<a class="headerlink" href="#state-families" title="Link to this heading">¶</a></h3>
<p>Provides functions to generate quantum states belonging to
specific families. Currently under development.</p>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="pyqch.state_families.computational_basis">
<span class="sig-prename descclassname"><span class="pre">pyqch.state_families.</span></span><span class="sig-name descname"><span class="pre">computational_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.state_families.computational_basis" title="Link to this definition">¶</a></dt>
<dd><p>Generates a quantum state in the computational basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – Dimension of the Hilbert space.</p></li>
<li><p><strong>index</strong> (<em>int</em>) – Index of the desired basis state.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The quantum state in the computational basis.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-pyqch">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-pyqch" title="Link to this heading">¶</a></h2>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">PyQch</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">pyqch</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">pyqch package</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  <li><a href="modules.html">pyqch</a><ul>
      <li>Previous: <a href="modules.html" title="previous chapter">pyqch</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Ruben Ibarrondo.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="_sources/pyqch.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>


<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pyqch package &mdash; PyQch 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=01f34227"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="pyqch" href="modules.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            PyQch
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">pyqch</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">pyqch package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-pyqch.base_change_unitaries">pyqch.base_change_unitaries module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#base-change-unitaries">base_change_unitaries</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.base_change_unitaries.el_gm"><code class="docutils literal notranslate"><span class="pre">el_gm()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.base_change_unitaries.gm_el"><code class="docutils literal notranslate"><span class="pre">gm_el()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-pyqch.channel_families">pyqch.channel_families module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#channel-families">channel_families</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.channel_families.amplitude_damping"><code class="docutils literal notranslate"><span class="pre">amplitude_damping()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.channel_families.classical_permutation"><code class="docutils literal notranslate"><span class="pre">classical_permutation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.channel_families.dephasing"><code class="docutils literal notranslate"><span class="pre">dephasing()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.channel_families.depolarizing"><code class="docutils literal notranslate"><span class="pre">depolarizing()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.channel_families.embed_classical"><code class="docutils literal notranslate"><span class="pre">embed_classical()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.channel_families.initializer"><code class="docutils literal notranslate"><span class="pre">initializer()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.channel_families.povm"><code class="docutils literal notranslate"><span class="pre">povm()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.channel_families.probabilistic_damping"><code class="docutils literal notranslate"><span class="pre">probabilistic_damping()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.channel_families.probabilistic_unitaries"><code class="docutils literal notranslate"><span class="pre">probabilistic_unitaries()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.channel_families.transposition"><code class="docutils literal notranslate"><span class="pre">transposition()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-pyqch.channel_operations">pyqch.channel_operations module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#channel-operations">channel_operations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.channel_operations.choi_state"><code class="docutils literal notranslate"><span class="pre">choi_state()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.channel_operations.doeblin_coefficient"><code class="docutils literal notranslate"><span class="pre">doeblin_coefficient()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.channel_operations.fixed_points"><code class="docutils literal notranslate"><span class="pre">fixed_points()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.channel_operations.kraus_operators"><code class="docutils literal notranslate"><span class="pre">kraus_operators()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.channel_operations.tensor"><code class="docutils literal notranslate"><span class="pre">tensor()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.channel_operations.twirling"><code class="docutils literal notranslate"><span class="pre">twirling()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-pyqch.divergences">pyqch.divergences module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#divergences">divergences</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.divergences.hockey_stick"><code class="docutils literal notranslate"><span class="pre">hockey_stick()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.divergences.hs_dist"><code class="docutils literal notranslate"><span class="pre">hs_dist()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.divergences.max_relative_entropy"><code class="docutils literal notranslate"><span class="pre">max_relative_entropy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.divergences.relative_entropy"><code class="docutils literal notranslate"><span class="pre">relative_entropy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.divergences.tr_dist"><code class="docutils literal notranslate"><span class="pre">tr_dist()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-pyqch.predicates">pyqch.predicates module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#predicates">predicates</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.predicates.is_channel"><code class="docutils literal notranslate"><span class="pre">is_channel()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.predicates.is_density_matrix"><code class="docutils literal notranslate"><span class="pre">is_density_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.predicates.is_system_compatible"><code class="docutils literal notranslate"><span class="pre">is_system_compatible()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-pyqch.random_generators">pyqch.random_generators module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#random-generators">random_generators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.random_generators.channel"><code class="docutils literal notranslate"><span class="pre">channel()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.random_generators.state"><code class="docutils literal notranslate"><span class="pre">state()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.random_generators.state_dirichlet"><code class="docutils literal notranslate"><span class="pre">state_dirichlet()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.random_generators.unitary_channel"><code class="docutils literal notranslate"><span class="pre">unitary_channel()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-pyqch.state_families">pyqch.state_families module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#state-families">state_families</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.state_families.computational_basis"><code class="docutils literal notranslate"><span class="pre">computational_basis()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.state_families.maximally_entangled"><code class="docutils literal notranslate"><span class="pre">maximally_entangled()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pyqch-state-transformations-module">pyqch.state_transformations module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#state-transformations">state_transformations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.state_transformations.local_channel"><code class="docutils literal notranslate"><span class="pre">local_channel()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.state_transformations.low_rank_representation"><code class="docutils literal notranslate"><span class="pre">low_rank_representation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.state_transformations.partial_trace"><code class="docutils literal notranslate"><span class="pre">partial_trace()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.state_transformations.subsystem_permutation"><code class="docutils literal notranslate"><span class="pre">subsystem_permutation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.state_transformations.subsystem_reshape"><code class="docutils literal notranslate"><span class="pre">subsystem_reshape()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyqch.state_transformations.twirling"><code class="docutils literal notranslate"><span class="pre">twirling()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PyQch</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="modules.html">pyqch</a></li>
      <li class="breadcrumb-item active">pyqch package</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/RubenIbarrondo/quantum_channels/blob/main/docs/pyqch.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="pyqch-package">
<h1>pyqch package<a class="headerlink" href="#pyqch-package" title="Link to this heading"></a></h1>
<section id="module-pyqch.base_change_unitaries">
<span id="pyqch-base-change-unitaries-module"></span><h2>pyqch.base_change_unitaries module<a class="headerlink" href="#module-pyqch.base_change_unitaries" title="Link to this heading"></a></h2>
<section id="base-change-unitaries">
<h3>base_change_unitaries<a class="headerlink" href="#base-change-unitaries" title="Link to this heading"></a></h3>
<p>This module implements functions that return unitaries for transforming
density matrices between different bases. It currently includes transformations
related to the generalized Gell-Mann basis and the element-wise (computational
or canonical) basis, with potential for future extensions to other transformations.</p>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="pyqch.base_change_unitaries.el_gm">
<span class="sig-prename descclassname"><span class="pre">pyqch.base_change_unitaries.</span></span><span class="sig-name descname"><span class="pre">el_gm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.base_change_unitaries.el_gm" title="Link to this definition"></a></dt>
<dd><p>Returns the unitary matrix that transforms from the element-wise
(computational) basis to the coefficients in the generalized
Gell-Mann normalized basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dim</strong> (<em>int</em>) – The dimension of the Hilbert space.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The unitary matrix for the basis transformation.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#pyqch.base_change_unitaries.gm_el" title="pyqch.base_change_unitaries.gm_el"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gm_el</span></code></a></dt><dd><p>Returns the inverse transformation.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">base_change_unitaries</span> <span class="kn">import</span> <span class="n">el_gm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dim</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">U_el_gm</span> <span class="o">=</span> <span class="n">gm_el</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Define a density matrix in the computational basis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Transform the density matrix to the Gell-Mann basis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho_gm</span> <span class="o">=</span> <span class="n">U_el_gm</span> <span class="o">@</span> <span class="n">rho</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dim</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;rho in Gell-Mann basis:&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rho_gm</span><span class="p">)</span>
<span class="go">[0.38723499+0.j 0.        +0.j 0.21213203+0.j 0.        +0.j</span>
<span class="go"> 0.38723499+0.j 0.        +0.j 0.21213203+0.j 0.        +0.j</span>
<span class="go"> 0.2647605 +0.j]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.base_change_unitaries.gm_el">
<span class="sig-prename descclassname"><span class="pre">pyqch.base_change_unitaries.</span></span><span class="sig-name descname"><span class="pre">gm_el</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.base_change_unitaries.gm_el" title="Link to this definition"></a></dt>
<dd><p>Returns the unitary matrix that transforms from the coefficients in the
generalized Gell-Mann normalized basis to the element-wise (computational) basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dim</strong> (<em>int</em>) – The dimension of the Hilbert space.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The unitary matrix for the basis transformation.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#pyqch.base_change_unitaries.el_gm" title="pyqch.base_change_unitaries.el_gm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">el_gm</span></code></a></dt><dd><p>Returns the inverse transformation.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Gell-Mann matrices are a generalization of the Pauli matrices used to
describe higher-dimensional systems in quantum mechanics <a class="footnote-reference brackets" href="#id3" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. They form a
complete, orthogonal basis for the space of Hermitian matrices.</p>
<p>The d&gt;3 generalization is taken as in <a class="footnote-reference brackets" href="#id4" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> (Eq. 8).</p>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id3" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Gell-Mann_matrices">https://en.wikipedia.org/wiki/Gell-Mann_matrices</a></p>
</aside>
<aside class="footnote brackets" id="id4" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>Jens Siewert 2022 J. Phys. Commun. 6 055014</p>
</aside>
</aside>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">base_change_unitaries</span> <span class="kn">import</span> <span class="n">gm_el</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">U_el_gm</span> <span class="o">=</span> <span class="n">el_gm</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># Transforms from the normalized Pauli basis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Define a density matrix in the Pauli basis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho_pauli</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Transform the density matrix to the element-wise basis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span> <span class="o">=</span> <span class="p">(</span><span class="n">U_el_gm</span> <span class="o">@</span> <span class="n">rho_pauli</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;rho in element-wise basis:&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
<span class="go">[[ 0.5  0.5 ]</span>
<span class="go"> [ 0.5  0.5 ]]</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-pyqch.channel_families">
<span id="pyqch-channel-families-module"></span><h2>pyqch.channel_families module<a class="headerlink" href="#module-pyqch.channel_families" title="Link to this heading"></a></h2>
<section id="channel-families">
<h3>channel_families<a class="headerlink" href="#channel-families" title="Link to this heading"></a></h3>
<p>This module implements functions that return the transition matrices or
Kraus representation describing different families of quantum channels.</p>
<p>These functions cover a variety of channels including classical permutations,
dephasing, depolarizing, embedding classical channels, initializers,
POVMs, probabilistic damping, and probabilistic unitaries.</p>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="pyqch.channel_families.amplitude_damping">
<span class="sig-prename descclassname"><span class="pre">pyqch.channel_families.</span></span><span class="sig-name descname"><span class="pre">amplitude_damping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lamb</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kraus_representation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.channel_families.amplitude_damping" title="Link to this definition"></a></dt>
<dd><p>Amplitude damping in arbitrary dimension.</p>
<p>It describes the coherent damping from state <a href="#id5"><span class="problematic" id="id6">|</span></a>x&gt; to <a href="#id7"><span class="problematic" id="id8">|</span></a>y&gt;.</p>
<p>Reduces to the usual qubit amplitude damping for dim=0, x=1, y=0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of the Hilbert space.</p></li>
<li><p><strong>lamb</strong> (<em>float</em>) – The damping parameter ranging from 0 to 1.</p></li>
<li><p><strong>x</strong> (<em>np.ndarray</em><em> | </em><em>int</em><em>, </em><em>optional</em>) – The origin state for the damping, by default 1. If int, it is interpreted as a basis state.</p></li>
<li><p><strong>y</strong> (<em>np.ndarray</em><em> | </em><em>int</em><em>, </em><em>optional</em>) – The target state for the damping, by default 0. If int, it is interpreted as a basis state.</p></li>
<li><p><strong>kraus_representation</strong> (<em>bool</em><em>, </em><em>optional</em>) – If true, the function returns the Kraus representation of the channel with shape
(Kraus operator index, dim2, dim1), defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transition matrix or Kraus operators representing the amplitude damping channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For the general d-dimensional formulation we considered Definition 1 in <a class="footnote-reference brackets" href="#id10" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>.</p>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id10" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">3</a><span class="fn-bracket">]</span></span>
<p>Frederik vom Ende, (2024) “A Sufficient Criterion for Divisibility of Quantum Channels”. arXiv: 2407.17103</p>
</aside>
</aside>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If lambda not in [0, 1]; x or y are int and are not in [0, dim), or are np.ndarray and shape not compatible with (dim,1).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.channel_families.classical_permutation">
<span class="sig-prename descclassname"><span class="pre">pyqch.channel_families.</span></span><span class="sig-name descname"><span class="pre">classical_permutation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">perm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kraus_representation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.channel_families.classical_permutation" title="Link to this definition"></a></dt>
<dd><p>Returns the transition matrix representing a classical permutation
channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of the Hilbert space.</p></li>
<li><p><strong>perm</strong> (<em>list</em>) – The array defining the permutation that maps i to perm[i].</p></li>
<li><p><strong>kraus_representation</strong> (<em>bool</em><em>, </em><em>optional</em>) – Defaults to False. WARNING: This map does not admit a Kraus representation, if it
is set to True it will rise a ValueError.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transition matrix representing the classical permutation channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_families</span> <span class="kn">import</span> <span class="n">classical_permutation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">perm</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">classical_permutation</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">[[0. 1. 0.]</span>
<span class="go"> [0. 0. 1.]</span>
<span class="go"> [1. 0. 0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.channel_families.dephasing">
<span class="sig-prename descclassname"><span class="pre">pyqch.channel_families.</span></span><span class="sig-name descname"><span class="pre">dephasing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kraus_representation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.channel_families.dephasing" title="Link to this definition"></a></dt>
<dd><p>Returns the transition matrix for a dephasing channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of the Hilbert space.</p></li>
<li><p><strong>g</strong> (<em>float</em><em> | </em><em>np.ndarray</em>) – Dephasing strength. If float, it is used as an uniform damping for all
off-diagonal terms; if np.ndarray, g[i,j] describes the damping of the
element (i,j).
The validity of g to define an appropriate dephasing channel is not verified.</p></li>
<li><p><strong>u</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – The unitary matrix defining the basis in which dephasing occurs.
Defaults to the identity matrix.</p></li>
<li><p><strong>kraus_representation</strong> (<em>bool</em><em>, </em><em>optional</em>) – If true, the function returns the Kraus representation of the channel with shape
(Kraus operator index, dim2, dim1), defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transition matrix or Kraus operators for the dephasing channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function implements dephasing by dampening the off-diagonal terms
in a given basis. If g is a matrix, it should be real, symmetric, positive
semi-definite and all diagonal terms equal to one.</p>
<p>For other generalized dephasing, one could define the corresponding
PVMs and include an identity with some dampening, then pass them to
the <cite>povm</cite> function.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_families</span> <span class="kn">import</span> <span class="n">dephasing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dim</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="mf">0.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">dephasing</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">[[1. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ],</span>
<span class="go">   [0. , 0.6, 0. , 0. , 0. , 0. , 0. , 0. , 0. ],</span>
<span class="go">   [0. , 0. , 0.6, 0. , 0. , 0. , 0. , 0. , 0. ],</span>
<span class="go">   [0. , 0. , 0. , 0.6, 0. , 0. , 0. , 0. , 0. ],</span>
<span class="go">   [0. , 0. , 0. , 0. , 1. , 0. , 0. , 0. , 0. ],</span>
<span class="go">   [0. , 0. , 0. , 0. , 0. , 0.6, 0. , 0. , 0. ],</span>
<span class="go">   [0. , 0. , 0. , 0. , 0. , 0. , 0.6, 0. , 0. ],</span>
<span class="go">   [0. , 0. , 0. , 0. , 0. , 0. , 0. , 0.6, 0. ],</span>
<span class="go">   [0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 1. ]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.channel_families.depolarizing">
<span class="sig-prename descclassname"><span class="pre">pyqch.channel_families.</span></span><span class="sig-name descname"><span class="pre">depolarizing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kraus_representation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kraus_atol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-07</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.channel_families.depolarizing" title="Link to this definition"></a></dt>
<dd><p>Returns the transition matrix for a depolarizing channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of the Hilbert space.</p></li>
<li><p><strong>p</strong> (<em>float</em>) – Depolarizing probability.</p></li>
<li><p><strong>r</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – The stationary state of the depolarizing channel. Defaults to the
completely mixed state.</p></li>
<li><p><strong>kraus_representation</strong> (<em>bool</em><em>, </em><em>optional</em>) – If true, the function returns the Kraus representation of the channel with shape
(Kraus operator index, dim2, dim1), defaults to False.</p></li>
<li><p><strong>kraus_atol</strong> (<em>float</em><em>, </em><em>optional</em>) – The tolerance to neglect a Kraus operator, defaults to 1e-7.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transition matrix or Kraus operators for the depolarizing channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_families</span> <span class="kn">import</span> <span class="n">depolarizing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dim</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">depolarizing</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho_out</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span> <span class="o">@</span> <span class="n">rho_in</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dim</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rho_out</span><span class="p">)</span>
<span class="go">[[0.86666667+0.j 0.        +0.j 0.        +0.j]</span>
<span class="go"> [0.        +0.j 0.06666667+0.j 0.        +0.j]</span>
<span class="go"> [0.        +0.j 0.        +0.j 0.06666667+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.channel_families.embed_classical">
<span class="sig-prename descclassname"><span class="pre">pyqch.channel_families.</span></span><span class="sig-name descname"><span class="pre">embed_classical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stoch_mat</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kraus_representation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kraus_atol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-07</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.channel_families.embed_classical" title="Link to this definition"></a></dt>
<dd><p>Embeds a classical stochastic matrix into a quantum transition matrix.</p>
<p>The resulting process sets off-diagonal terms to zero and acts on the diagonal
terms following the classical stochastic process.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of the input Hilbert space.</p></li>
<li><p><strong>stoch_mat</strong> (<em>np.ndarray</em>) – The classical column-stochastic matrix to be embedded.</p></li>
<li><p><strong>kraus_representation</strong> (<em>bool</em><em>, </em><em>optional</em>) – If true, the function returns the Kraus representation of the channel with shape
(Kraus operator index, dim2, dim1), defaults to False.</p></li>
<li><p><strong>kraus_atol</strong> (<em>float</em><em>, </em><em>optional</em>) – The tolerance to neglect a Kraus operator, defaults to 1e-7.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transition matrix or Kraus operators representing the embedded classical channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_families</span> <span class="kn">import</span> <span class="n">embed_classical</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stoch_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">embed_classical</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">stoch_mat</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">[[0.8 0.  0.  0.3]</span>
<span class="go"> [0.  0.  0.  0. ]</span>
<span class="go"> [0.  0.  0.  0. ]</span>
<span class="go"> [0.2 0.  0.  0.7]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.channel_families.initializer">
<span class="sig-prename descclassname"><span class="pre">pyqch.channel_families.</span></span><span class="sig-name descname"><span class="pre">initializer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'c-q'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kraus_representation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kraus_atol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-07</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.channel_families.initializer" title="Link to this definition"></a></dt>
<dd><p>Returns a transition matrix for initializing a quantum state.</p>
<p>The initializer channel takes a classical probability distribution as
input and produces a density matrix.</p>
<p>The <cite>mode</cite> argument defines the format of the input and output states.
The initial state can be a classical array (c) or a density matrix whose
diagonal elements are used as the input probability distribution (q),
discarding off-diagonal terms. The output state can store only the
initialized states (q) or also the input probability distribution (qc)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of the output Hilbert space.</p></li>
<li><p><strong>states</strong> (<em>np.ndarray</em>) – Array of states defining the choices for initialization.
The expected shape is either (number of states, dim, dim) or
(number of states, dim) , such that states[i] represents the
state prepared when the classical variable takes the value i (described
as a density matrix or as a vector).</p></li>
<li><p><strong>mode</strong> (<em>str</em><em>, </em><em>optional</em>) – Mode of initialization (‘c-q’ for classical to quantum,
‘c-qc’ for classical to quantum and classical, ‘q-q’ for
quantum to quantum, ‘q-qc’ for quantum to quantum and
classical). Defaults to ‘c-q’.</p></li>
<li><p><strong>kraus_representation</strong> (<em>bool</em><em>, </em><em>optional</em>) – If true, the function returns the Kraus representation of the channel with shape
(Kraus operator index, dim2, dim1), defaults to False.
Some modes do not admit a Kraus representation.</p></li>
<li><p><strong>kraus_atol</strong> (<em>float</em><em>, </em><em>optional</em>) – The tolerance to neglect a Kraus operator, defaults to 1e-7.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transition matrix or Kraus operators for the initializer.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_families</span> <span class="kn">import</span> <span class="n">initializer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
<span class="go">                        [[.5, .5], [.5, .5]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">initializer</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">states</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">[[1.  0.5]</span>
<span class="go"> [0.  0.5]</span>
<span class="go"> [0.  0.5]</span>
<span class="go"> [0.  0.5]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.channel_families.povm">
<span class="sig-prename descclassname"><span class="pre">pyqch.channel_families.</span></span><span class="sig-name descname"><span class="pre">povm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'q-q'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kraus_representation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.channel_families.povm" title="Link to this definition"></a></dt>
<dd><p>Returns a transition matrix for a quantum channel defined by a
positive operator-valued measure (POVM).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of the Hilbert space.</p></li>
<li><p><strong>pos</strong> (<em>np.ndarray</em>) – The POVM elements defining the channel. The expected shape is
(number of positive operators, dim, dim), such that pos[i] is
the ith positive operator.</p></li>
<li><p><strong>mode</strong> (<em>str</em><em>, </em><em>optional</em>) – Mode of the channel (‘q-q’ for quantum to quantum,
‘q-c’ for quantum to classical, ‘q-qc’ for quantum to
quantum and classical). Defaults to ‘q-q’.</p></li>
<li><p><strong>kraus_representation</strong> (<em>bool</em><em>, </em><em>optional</em>) – If true, the function returns the Kraus representation of the channel with shape
(Kraus operator index, dim2, dim1), defaults to False.
Some modes do not admit a Kraus representation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transition matrix or Kraus operators for the POVM-based quantum channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_families</span> <span class="kn">import</span> <span class="n">povm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">povm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">[[1 0 0 0]</span>
<span class="go"> [0 0 0 0]</span>
<span class="go"> [0 0 0 0]</span>
<span class="go"> [0 0 0 1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.channel_families.probabilistic_damping">
<span class="sig-prename descclassname"><span class="pre">pyqch.channel_families.</span></span><span class="sig-name descname"><span class="pre">probabilistic_damping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kraus_representation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.channel_families.probabilistic_damping" title="Link to this definition"></a></dt>
<dd><p>Returns a transition matrix for a probabilistic damping channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of the Hilbert space.</p></li>
<li><p><strong>p</strong> (<em>float</em>) – Damping probability.</p></li>
<li><p><strong>kraus_representation</strong> (<em>bool</em><em>, </em><em>optional</em>) – If true, the function returns the Kraus representation of the channel with shape
(Kraus operator index, dim2, dim1), defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transition matrix or Kraus operators for the probabilistic damping channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_families</span> <span class="kn">import</span> <span class="n">probabilistic_damping</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">probabilistic_damping</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">[[1.  0.  0.  0.1]</span>
<span class="go"> [0.  0.9 0.  0. ]</span>
<span class="go"> [0.  0.  0.9 0. ]</span>
<span class="go"> [0.  0.  0.  0.9]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.channel_families.probabilistic_unitaries">
<span class="sig-prename descclassname"><span class="pre">pyqch.channel_families.</span></span><span class="sig-name descname"><span class="pre">probabilistic_unitaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_arr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_arr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kraus_representation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.channel_families.probabilistic_unitaries" title="Link to this definition"></a></dt>
<dd><p>Returns a transition matrix for a channel that applies unitaries
probabilistically.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of the Hilbert space.</p></li>
<li><p><strong>p_arr</strong> (<em>np.ndarray</em>) – Probabilities for each unitary operation.</p></li>
<li><p><strong>u_arr</strong> (<em>np.ndarray</em>) – Array of unitary matrices. The expected shape is
(number of unitaries, dim, dim), such that u_arr[i] is
the ith possible unitary.</p></li>
<li><p><strong>kraus_representation</strong> (<em>bool</em><em>, </em><em>optional</em>) – If true, the function returns the Kraus representation of the channel with shape
(Kraus operator index, dim2, dim1), defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transition matrix or Kraus operators for the probabilistic unitary channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>This example demonstrates the implementation of a bit-flip channel.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_families</span> <span class="kn">import</span> <span class="n">probabilistic_unitaries</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">probabilistic_unitaries</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">p_arr</span><span class="p">,</span> <span class="n">u_arr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">[[0.5 0.  0.  0.5]</span>
<span class="go"> [0.  0.5 0.5 0. ]</span>
<span class="go"> [0.  0.5 0.5 0. ]</span>
<span class="go"> [0.5 0.  0.  0.5]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.channel_families.transposition">
<span class="sig-prename descclassname"><span class="pre">pyqch.channel_families.</span></span><span class="sig-name descname"><span class="pre">transposition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kraus_representation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.channel_families.transposition" title="Link to this definition"></a></dt>
<dd><p>Returns a transition matrix for the transposition operator. This is positive but
not completely positive, thus it is not a quantum channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of the Hilbert space.</p></li>
<li><p><strong>u</strong> (<em>np.ndarray</em><em> or </em><em>None</em>) – Basis in which the transposition is performed, if None the canonical basis is used.
Defaults to None.</p></li>
<li><p><strong>kraus_representation</strong> (<em>bool</em><em>, </em><em>optional</em>) – Defaults to False. WARNING: This map does not admit a Kraus representation, if it
is set to True it will rise a ValueError.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transition matrix for the transposition.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-pyqch.channel_operations">
<span id="pyqch-channel-operations-module"></span><h2>pyqch.channel_operations module<a class="headerlink" href="#module-pyqch.channel_operations" title="Link to this heading"></a></h2>
<section id="channel-operations">
<h3>channel_operations<a class="headerlink" href="#channel-operations" title="Link to this heading"></a></h3>
<p>This module implements various operations on quantum channels. It includes
functions for obtaining the Choi state of a channel, performing tensor
products of channel representations, and finding fixed points of a channel.</p>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="pyqch.channel_operations.choi_state">
<span class="sig-prename descclassname"><span class="pre">pyqch.channel_operations.</span></span><span class="sig-name descname"><span class="pre">choi_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.channel_operations.choi_state" title="Link to this definition"></a></dt>
<dd><p>Returns the Choi state representation of a given quantum channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>t</strong> (<em>np.ndarray</em>) – The transition matrix representing the quantum channel.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The Choi state corresponding to the quantum channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_operations</span> <span class="kn">import</span> <span class="n">choi_state</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_families</span> <span class="kn">import</span> <span class="n">depolarizing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="mf">.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">depolarizing</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">choi</span> <span class="o">=</span> <span class="n">choi_state</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">choi</span><span class="p">)</span>
<span class="go">[[0.375+0.j 0.   +0.j 0.   +0.j 0.25 +0.j]</span>
<span class="go"> [0.   +0.j 0.125+0.j 0.   +0.j 0.   +0.j]</span>
<span class="go"> [0.   +0.j 0.   +0.j 0.125+0.j 0.   +0.j]</span>
<span class="go"> [0.25 +0.j 0.   +0.j 0.   +0.j 0.375+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.channel_operations.doeblin_coefficient">
<span class="sig-prename descclassname"><span class="pre">pyqch.channel_operations.</span></span><span class="sig-name descname"><span class="pre">doeblin_coefficient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">channel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transpose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subspace_projection</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyqch.channel_operations.doeblin_coefficient" title="Link to this definition"></a></dt>
<dd><p>Computes the Doeblin coefficient of a quantum channel.</p>
<p>The Doeblin coefficient is the maximum erasure probability for which an erasure channel
can be degraded into the given channel. This implementation uses the SDP construction
described in reference [1].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>channel</strong> (<em>np.ndarray</em>) – The transition matrix representing the quantum channel.</p></li>
<li><p><strong>transpose</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to check transpose-degradability instead of the usual degradability.
Defaults to False.</p></li>
<li><p><strong>subspace_projection</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – An orthogonal projector into a subspace of dimension at least 2. If provided,
it restricts the search for the coefficient to that subspace. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The Doeblin coefficient of the quantum channel. Returns None if the problem is
infeasible or unbounded.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function implements the SDP (Semidefinite Programming) construction given
in reference [1] to find the Doeblin coefficient.</p>
<p>The subspace restriciton is not detailed in [1].</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#pyqch.channel_operations.choi_state" title="pyqch.channel_operations.choi_state"><code class="xref py py-obj docutils literal notranslate"><span class="pre">choi_state</span></code></a></dt><dd><p>Function to compute the Choi state of the channel.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">channel_families.transposition</span></code></dt><dd><p>Function to obtain the transition matrix of matrix transposition.</p>
</dd>
</dl>
</div>
<p class="rubric">References</p>
<p>[1] : C. Hirche (2024), “Quantum Doeblin coefficients: A simple upper bound on contraction
coefficients” (arXiv: 2405.00105)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.channel_operations.fixed_points">
<span class="sig-prename descclassname"><span class="pre">pyqch.channel_operations.</span></span><span class="sig-name descname"><span class="pre">fixed_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-06</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.channel_operations.fixed_points" title="Link to this definition"></a></dt>
<dd><p>Returns the fixed points of a given quantum channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<em>np.ndarray</em>) – The transition matrix representing the quantum channel.</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance for determining fixed points. Defaults to 1e-6.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The fixed points of the quantum channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>NotImplementedError</strong> – If more than one fixed point is detected.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_operations</span> <span class="kn">import</span> <span class="n">fixed_points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_families</span> <span class="kn">import</span> <span class="n">depolarizing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dim</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.3</span><span class="p">,</span> <span class="mf">.2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">depolarizing</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho_ref</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fixed_pt</span> <span class="o">=</span> <span class="n">fixed_points</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">fixed_pt</span><span class="p">,</span> <span class="n">rho_ref</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.channel_operations.kraus_operators">
<span class="sig-prename descclassname"><span class="pre">pyqch.channel_operations.</span></span><span class="sig-name descname"><span class="pre">kraus_operators</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-06</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.channel_operations.kraus_operators" title="Link to this definition"></a></dt>
<dd><p>Returns the Kraus operators of a given quantum channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<em>np.ndarray</em>) – The transition matrix representing the quantum channel,
with shape (dim2**2, dim1**2)</p></li>
<li><p><strong>atol</strong> (<em>float</em><em>, </em><em>optional</em>) – The absolute tolerance for the norm of a Kraus operator to be
considered as a non-trivial Kraus operator, defaults to 1e-6.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The Kraus operators corresponding to the quantum channel,
with shape (kraus_rank, dim2, dim1).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Currently, the method uses the spectral decomposition of the Choi matrix and discards
eigenvalues that are smaller than atol. This is equivalent to discarding Kraus operators
with np.trace(K.T &#64; K) &lt;= atol * dim1.</p>
<p>Using the matrix square root of the Choi matrix is a valid alternative if
the canonical form is not needed. It seems more efficient in cases where the
matrix is sparse.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.channel_operations.tensor">
<span class="sig-prename descclassname"><span class="pre">pyqch.channel_operations.</span></span><span class="sig-name descname"><span class="pre">tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_arr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.channel_operations.tensor" title="Link to this definition"></a></dt>
<dd><p>Returns the tensor product of quantum channels represented by their
transition matrices.</p>
<p>This function can be used in two ways:</p>
<ol class="arabic simple">
<li><p>Provide a list of transition matrices to compute their tensor product.</p></li>
<li><p>Provide a single transition matrix and a value for <cite>n</cite> to compute the
self-tensor product applied <cite>n</cite> times.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t_arr</strong> (<em>np.ndarray</em><em> or </em><em>list</em><em> of </em><em>np.ndarray</em>) – A single transition matrix or a list of transition matrices.</p></li>
<li><p><strong>n</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of times to apply the tensor product to a single transition
matrix. Ignored if <cite>t_arr</cite> is a list of matrices. Defaults to 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting tensor product of the transition matrices.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Define a qubit-depolarizing and a qubit identity channel.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_operations</span> <span class="kn">import</span> <span class="n">tensor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_families</span> <span class="kn">import</span> <span class="n">depolarizing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tdepol</span> <span class="o">=</span> <span class="n">depolarizing</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">dim</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Example 1: Tensor product of a list of matrices
Demonstrates how to construct an inhomogeneous local depolarizer that
acts on two qubits, but only adds noise to the state of the first qubit.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tensor_product</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">([</span><span class="n">tdepol</span><span class="p">,</span> <span class="n">tid</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tensor_product</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(16, 16)</span>
</pre></div>
</div>
<p>Example 2: Self-tensor product of a single matrix applied n times
Demostrates how to build a multi-qubit homogeneous depolarizing channel.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">local_depol</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">tdepol</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">local_depol</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64, 64)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.channel_operations.twirling">
<span class="sig-prename descclassname"><span class="pre">pyqch.channel_operations.</span></span><span class="sig-name descname"><span class="pre">twirling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_in</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_out</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyqch.channel_operations.twirling" title="Link to this definition"></a></dt>
<dd><p>Applies a twirling operation to a quantum channel.</p>
<p>The input is two representations of the finite group G, given as arrays of unitary matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<em>np.ndarray</em>) – The transition matrix representing the quantum channel.</p></li>
<li><p><strong>r_in</strong> (<em>list</em><em> of </em><em>np.ndarray</em>) – Input representation of the finite group with each element labeled by an integer.</p></li>
<li><p><strong>r_out</strong> (<em>list</em><em> of </em><em>np.ndarray</em>) – Output representation of the finite group with each element labeled by an integer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transition matrix of the twirled quantum channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If r_in and r_out do not have the same size.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_operations</span> <span class="kn">import</span> <span class="n">twirling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">random_generators</span> <span class="kn">import</span> <span class="n">channel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">channel</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">k_rank</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r_in</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_twirl</span> <span class="o">=</span> <span class="n">twirling</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">r_in</span><span class="p">,</span> <span class="n">r_out</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">t_twirl</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>This function applies a twirling operation, which averages the quantum channel over a group of unitary transformations.</p>
<div class="math notranslate nohighlight">
\[T_G(\mathcal{E})(\cdot) = \frac{1}{|G|} \sum_{g \in G} R_{out}(g^{-1}) \mathcal{E}(R_{in}(g) \cdot R_{in}(g)^\dagger) R_{out}(g^{-1})^\dagger\]</div>
</dd></dl>

</section>
<section id="module-pyqch.divergences">
<span id="pyqch-divergences-module"></span><h2>pyqch.divergences module<a class="headerlink" href="#module-pyqch.divergences" title="Link to this heading"></a></h2>
<section id="divergences">
<h3>divergences<a class="headerlink" href="#divergences" title="Link to this heading"></a></h3>
<p>This module implements various quantum divergences, which are bivariate functions
that assign a dissimilarity measure to quantum states.</p>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="pyqch.divergences.hockey_stick">
<span class="sig-prename descclassname"><span class="pre">pyqch.divergences.</span></span><span class="sig-name descname"><span class="pre">hockey_stick</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#pyqch.divergences.hockey_stick" title="Link to this definition"></a></dt>
<dd><p>Computes the hockey-stick divergence between two quantum states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rho</strong> (<em>np.ndarray</em>) – The first quantum state (density matrix).</p></li>
<li><p><strong>sigma</strong> (<em>np.ndarray</em>) – The second quantum state (density matrix).</p></li>
<li><p><strong>gamma</strong> (<em>float</em>) – The parameter gamma used in the divergence calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The hockey-stick divergence between the two states.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.float64</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gamma</span> <span class="o">=</span> <span class="mf">1.25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">divergence</span> <span class="o">=</span> <span class="n">hockey_stick</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)</span>
<span class="go">0.051776695296636865</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.divergences.hs_dist">
<span class="sig-prename descclassname"><span class="pre">pyqch.divergences.</span></span><span class="sig-name descname"><span class="pre">hs_dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#pyqch.divergences.hs_dist" title="Link to this definition"></a></dt>
<dd><p>Computes the Hilbert-Schmidt distance between two quantum states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rho</strong> (<em>np.ndarray</em>) – The first quantum state (density matrix).</p></li>
<li><p><strong>sigma</strong> (<em>np.ndarray</em>) – The second quantum state (density matrix).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The Hilbert-Schmidt distance between the two states.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.float64</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hs_dist</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
<span class="go">0.19999999999999998</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.divergences.max_relative_entropy">
<span class="sig-prename descclassname"><span class="pre">pyqch.divergences.</span></span><span class="sig-name descname"><span class="pre">max_relative_entropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#pyqch.divergences.max_relative_entropy" title="Link to this definition"></a></dt>
<dd><p>Computes the max-relative entropy between two quantum states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rho</strong> (<em>np.ndarray</em>) – The first quantum state (density matrix).</p></li>
<li><p><strong>sigma</strong> (<em>np.ndarray</em>) – The second quantum state (density matrix).</p></li>
<li><p><strong>basis</strong> (<em>int</em><em>, </em><em>optional</em>) – The logarithmic base for the entropy calculation. Defaults to 2.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The max-relative entropy between the two states.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.float64</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_relative_entropy</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
<span class="go">0.4796385281957086</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.divergences.relative_entropy">
<span class="sig-prename descclassname"><span class="pre">pyqch.divergences.</span></span><span class="sig-name descname"><span class="pre">relative_entropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#pyqch.divergences.relative_entropy" title="Link to this definition"></a></dt>
<dd><p>Computes the relative entropy (Kullback-Leibler divergence) between two quantum states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rho</strong> (<em>np.ndarray</em>) – The first quantum state (density matrix).</p></li>
<li><p><strong>sigma</strong> (<em>np.ndarray</em>) – The second quantum state (density matrix).</p></li>
<li><p><strong>basis</strong> (<em>int</em><em>, </em><em>optional</em>) – The logarithmic base for the entropy calculation. Defaults to 2.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The relative entropy between the two states.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.float64</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropy</span> <span class="o">=</span> <span class="n">relative_entropy</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
<span class="go">0.060147116858855876</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.divergences.tr_dist">
<span class="sig-prename descclassname"><span class="pre">pyqch.divergences.</span></span><span class="sig-name descname"><span class="pre">tr_dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#pyqch.divergences.tr_dist" title="Link to this definition"></a></dt>
<dd><p>Computes the trace distance between two quantum states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rho</strong> (<em>np.ndarray</em>) – The first quantum state (density matrix).</p></li>
<li><p><strong>sigma</strong> (<em>np.ndarray</em>) – The second quantum state (density matrix).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The trace distance between the two states.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.float64</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tr_dist</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
<span class="go">0.1414213562373095</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-pyqch.predicates">
<span id="pyqch-predicates-module"></span><h2>pyqch.predicates module<a class="headerlink" href="#module-pyqch.predicates" title="Link to this heading"></a></h2>
<section id="predicates">
<h3>predicates<a class="headerlink" href="#predicates" title="Link to this heading"></a></h3>
<p>This module contains functions to check whether a given matrix is a density matrix
or a quantum channel.</p>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="pyqch.predicates.is_channel">
<span class="sig-prename descclassname"><span class="pre">pyqch.predicates.</span></span><span class="sig-name descname"><span class="pre">is_channel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pyqch.predicates.is_channel" title="Link to this definition"></a></dt>
<dd><p>Checks if the given matrix is a valid quantum channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<em>np.ndarray</em>) – The transition matrix representing the quantum channel.</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance for the numerical checks. Defaults to 1e-6.</p></li>
<li><p><strong>show</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, prints the results of the various tests performed. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the matrix is a valid quantum channel, False otherwise.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">predicates</span> <span class="kn">import</span> <span class="n">is_channel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">channel_families</span> <span class="kn">import</span> <span class="n">depolarizing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dim</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tdepol</span> <span class="o">=</span> <span class="n">depolarizing</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_channel</span><span class="p">(</span><span class="n">tdepol</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="mf">2.5</span> <span class="o">*</span> <span class="n">tdepol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">is_channel</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">show</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">For the Choi matrix of the channel:</span>
<span class="go">Trace diff:  1.4999999999999996</span>
<span class="go">Hermiticity diff:  0.0</span>
<span class="go">Minimum eigval:  0.1388888888888888</span>
<span class="go">Channel is not trace preserving.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.predicates.is_density_matrix">
<span class="sig-prename descclassname"><span class="pre">pyqch.predicates.</span></span><span class="sig-name descname"><span class="pre">is_density_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pyqch.predicates.is_density_matrix" title="Link to this definition"></a></dt>
<dd><p>Checks if the given matrix is a valid density matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dm</strong> (<em>np.ndarray</em>) – The matrix to be checked.</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance for the numerical checks. Defaults to 1e-6.</p></li>
<li><p><strong>show</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, prints the results of the various tests performed. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the matrix is a valid density matrix, False otherwise.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">predicates</span> <span class="kn">import</span> <span class="n">is_density_matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">is_density_matrix</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Trace diff:  0.0</span>
<span class="go">Hermiticity diff:  0.0</span>
<span class="go">Minimum eigval:  0.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">is_density_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Trace diff:  0.0</span>
<span class="go">Hermiticity diff:  0.0</span>
<span class="go">Minimum eigval:  -0.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.predicates.is_system_compatible">
<span class="sig-prename descclassname"><span class="pre">pyqch.predicates.</span></span><span class="sig-name descname"><span class="pre">is_system_compatible</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pyqch.predicates.is_system_compatible" title="Link to this definition"></a></dt>
<dd><p>Checks if the given state and system structure are compatible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> (<em>np.ndarray</em>) – The density matrix of the state.</p></li>
<li><p><strong>system</strong> (<em>tuple</em><em>[</em><em>int</em><em>]</em>) – The system structure represented by a tupe with the local
dimension of the constituent subsystems.</p></li>
<li><p><strong>show</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, prints the results of the various tests performed. by default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the state and system structure are compatible, False otherwise.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-pyqch.random_generators">
<span id="pyqch-random-generators-module"></span><h2>pyqch.random_generators module<a class="headerlink" href="#module-pyqch.random_generators" title="Link to this heading"></a></h2>
<section id="random-generators">
<h3>random_generators<a class="headerlink" href="#random-generators" title="Link to this heading"></a></h3>
<p>This module contains functions to generate random quantum channels and states by sampling from various distributions.</p>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="pyqch.random_generators.channel">
<span class="sig-prename descclassname"><span class="pre">pyqch.random_generators.</span></span><span class="sig-name descname"><span class="pre">channel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim_in</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim_out</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kraus_rank</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Generator</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.random_generators.channel" title="Link to this definition"></a></dt>
<dd><p>Generates a random quantum channel by generating a random isometry
(truncated Haar-random unitary) and tracing out the environment.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim_in</strong> (<em>int</em>) – Input dimension of the quantum channel.</p></li>
<li><p><strong>dim_out</strong> (<em>int</em><em>, </em><em>optional</em>) – Output dimension of the quantum channel. If None, defaults to dim_in.</p></li>
<li><p><strong>kraus_rank</strong> (<em>int</em><em>, </em><em>optional</em>) – Rank of the Kraus operators representing the quantum channel. If None, defaults to dim_in * dim_out.</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em> | </em><em>np.random.Generator</em><em>, </em><em>optional</em>) – Used for drawing random variates. If seed is None, the RandomState singleton is used.
If seed is an int, a new RandomState instance is used, seeded with seed. If seed is
already a RandomState or Generator instance, then that object is used. Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transition matrix representing the random quantum channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">random_generators</span> <span class="kn">import</span> <span class="n">channel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dim_in</span><span class="p">,</span> <span class="n">dim_out</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">channel</span><span class="p">(</span><span class="n">dim_in</span><span class="p">,</span> <span class="n">dim_out</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(9, 4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.random_generators.state">
<span class="sig-prename descclassname"><span class="pre">pyqch.random_generators.</span></span><span class="sig-name descname"><span class="pre">state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Generator</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.random_generators.state" title="Link to this definition"></a></dt>
<dd><p>Generates a random quantum state by sampling Haar random
pure states on dimension dim * rank and computing the
partiual trace on rank degrees of freedom.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – Dimension of the quantum state.</p></li>
<li><p><strong>rank</strong> (<em>int</em><em>, </em><em>optional</em>) – Rank of the state. If None, defaults to dim.</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em> | </em><em>np.random.Generator</em><em>, </em><em>optional</em>) – Used for drawing random variates. If seed is None, the RandomState singleton is used.
If seed is an int, a new RandomState instance is used, seeded with seed. If seed is
already a RandomState or Generator instance, then that object is used. Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The random quantum state.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">random_generators</span> <span class="kn">import</span> <span class="n">state</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rank</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span> <span class="o">=</span> <span class="n">state</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
<span class="go">[[ 0.7984795 +3.77722651e-19j -0.21614672+3.37920970e-01j]</span>
<span class="go"> [-0.21614672-3.37920970e-01j  0.2015205 -3.08140272e-18j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.random_generators.state_dirichlet">
<span class="sig-prename descclassname"><span class="pre">pyqch.random_generators.</span></span><span class="sig-name descname"><span class="pre">state_dirichlet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Generator</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.random_generators.state_dirichlet" title="Link to this definition"></a></dt>
<dd><p>Generates random quantum states by sampling their spectrum from the homogeneous Dirichlet distribution
with concentration parameter alpha. The basis are rotated with Haar random unitary matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – Dimension of the quantum state.</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – Concentration parameter of the Dirichlet distribution.</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em> | </em><em>np.random.Generator</em><em>, </em><em>optional</em>) – Used for drawing random variates. If seed is None, the RandomState singleton is used.
If seed is an int, a new RandomState instance is used, seeded with seed. If seed is
already a RandomState or Generator instance, then that object is used. Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The random quantum state.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As alpha -&gt; 0 generated states are more pure, alpha = 1 is
equivalent to a Hilbert-Schmidt uniform measure, and as
alpha -&gt; infty it concentrates around the maximally mixed
state.</p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">random_generators</span> <span class="kn">import</span> <span class="n">state_dirichlet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span> <span class="o">=</span> <span class="n">state_dirichlet</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
<span class="go">[[ 0.33869694+0.j        -0.24593237-0.4043495j]</span>
<span class="go"> [-0.24593237+0.4043495j  0.66130306+0.j       ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.random_generators.unitary_channel">
<span class="sig-prename descclassname"><span class="pre">pyqch.random_generators.</span></span><span class="sig-name descname"><span class="pre">unitary_channel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Generator</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.random_generators.unitary_channel" title="Link to this definition"></a></dt>
<dd><p>Generates a random unitary quantum channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – Dimension of the Holbert space.</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em> | </em><em>np.random.Generator</em><em>, </em><em>optional</em>) – Used for drawing random variates. If seed is None, the RandomState singleton is used.
If seed is an int, a new RandomState instance is used, seeded with seed. If seed is
already a RandomState or Generator instance, then that object is used. Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transition matrix representing the random unitary quantum channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">random_generators</span> <span class="kn">import</span> <span class="n">unitary_channel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">U</span> <span class="o">=</span> <span class="n">unitary_channel</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">U</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">U</span> <span class="o">@</span> <span class="n">U</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">dim</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-pyqch.state_families">
<span id="pyqch-state-families-module"></span><h2>pyqch.state_families module<a class="headerlink" href="#module-pyqch.state_families" title="Link to this heading"></a></h2>
<section id="state-families">
<h3>state_families<a class="headerlink" href="#state-families" title="Link to this heading"></a></h3>
<p>Provides functions to generate quantum states belonging to
specific families. Currently under development.</p>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="pyqch.state_families.computational_basis">
<span class="sig-prename descclassname"><span class="pre">pyqch.state_families.</span></span><span class="sig-name descname"><span class="pre">computational_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">as_density_matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.state_families.computational_basis" title="Link to this definition"></a></dt>
<dd><p>Generates a quantum state in the computational basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – Dimension of the Hilbert space.</p></li>
<li><p><strong>index</strong> (<em>int</em>) – Index of the desired basis state.</p></li>
<li><p><strong>as_density_matrix</strong> (<em>bool</em>) – Whether the state is returned as a density matrix, by default False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The quantum state in the computational basis.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.state_families.maximally_entangled">
<span class="sig-prename descclassname"><span class="pre">pyqch.state_families.</span></span><span class="sig-name descname"><span class="pre">maximally_entangled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">as_density_matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.state_families.maximally_entangled" title="Link to this definition"></a></dt>
<dd><p>Generates a maximally entangled state in the computational basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – Dimension of the Hilbert space.</p></li>
<li><p><strong>as_density_matrix</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether the state is returned as a density matrix, by default False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The maximally entangled state.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="pyqch-state-transformations-module">
<h2>pyqch.state_transformations module<a class="headerlink" href="#pyqch-state-transformations-module" title="Link to this heading"></a></h2>
<section id="state-transformations">
<span id="module-pyqch.state_transformations"></span><h3>state_transformations<a class="headerlink" href="#state-transformations" title="Link to this heading"></a></h3>
<p>This module contains functions to directly transform density matrices. Such as,
subsystem permutations or applying a quantum channel in a subsystem without
having to build the transfer matrix for the whole system.</p>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="pyqch.state_transformations.local_channel">
<span class="sig-prename descclassname"><span class="pre">pyqch.state_transformations.</span></span><span class="sig-name descname"><span class="pre">local_channel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">active_sites</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.state_transformations.local_channel" title="Link to this definition"></a></dt>
<dd><p>Applies the channel to the state in the chosen sites.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> (<em>np.ndarray</em>) – Density matrix of the state.</p></li>
<li><p><strong>system</strong> (<em>tuple</em><em>[</em><em>int</em><em>]</em>) – The system structure represented by a tuple with the local
dimension of the constituent subsystems.</p></li>
<li><p><strong>active_sites</strong> (<em>tuple</em><em>[</em><em>int</em><em>] </em><em>| </em><em>int</em>) – The sites in which the channel acts on. If the channel’s input and output dimensions
are equal, the order of the sites is used to arrange the sites before applying the channel
and recover them back. If the channel’s output dimension differs from the input active_sites collapse
to a single site in the relative position corresponding to active_sites[0].</p></li>
<li><p><strong>channel</strong> (<em>np.ndarray</em>) – The transition matrix of the quantum channel.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Density matrix of the state resulting from applying the channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.state_transformations.low_rank_representation">
<span class="sig-prename descclassname"><span class="pre">pyqch.state_transformations.</span></span><span class="sig-name descname"><span class="pre">low_rank_representation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank_atol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_rank</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.state_transformations.low_rank_representation" title="Link to this definition"></a></dt>
<dd><p>Generates a low rank representation of a density matrix with shape (effective rank, dim), or the reverse transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> (<em>np.ndarray</em>) – Density matrix representation of the input state, or a low rank representation if reverse is True.</p></li>
<li><p><strong>rank_atol</strong> (<em>float</em><em>, </em><em>optional</em>) – Absolute tolerance of accumulated probability in the discarded eigenvalues, by default 1e-7. It is overwritten by output_rank.</p></li>
<li><p><strong>output_rank</strong> (<em>int</em><em>, </em><em>optional</em>) – Set the rank of the representation to a fixed value, by default None and rank_atol is used.</p></li>
<li><p><strong>reverse</strong> (<em>bool</em><em>, </em><em>optional</em>) – If true, implements the reverse transformation, by default False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Low rank representation of the state, or the density matrix representation if reverse is True.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.state_transformations.partial_trace">
<span class="sig-prename descclassname"><span class="pre">pyqch.state_transformations.</span></span><span class="sig-name descname"><span class="pre">partial_trace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">traced_sites</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_sites</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.state_transformations.partial_trace" title="Link to this definition"></a></dt>
<dd><p>Computes the partial trace on the state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> (<em>np.ndarray</em>) – Density matrix of the state to be traced.</p></li>
<li><p><strong>system</strong> (<em>tuple</em><em>[</em><em>int</em><em>]</em>) – The system structure represented by a tuple with the local
dimension of the constituent subsystems.</p></li>
<li><p><strong>traced_sites</strong> (<em>tuple</em><em>[</em><em>int</em><em>] </em><em>| </em><em>int</em>) – Site(s) in the system structure that will be traced out.</p></li>
<li><p><strong>keep_sites</strong> (<em>bool</em><em> (</em><em>optional</em><em>)</em>) – If True, <cite>traced_sites</cite> specifies the subsystems to keep rather than trace out. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The density matrix of the state resulting from the partial trace.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.state_transformations.subsystem_permutation">
<span class="sig-prename descclassname"><span class="pre">pyqch.state_transformations.</span></span><span class="sig-name descname"><span class="pre">subsystem_permutation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">permutation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.state_transformations.subsystem_permutation" title="Link to this definition"></a></dt>
<dd><p>Performs the permutation of the subsystems on the state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> (<em>np.ndarray</em>) – The density matrix of the state.</p></li>
<li><p><strong>system</strong> (<em>tuple</em><em>[</em><em>int</em><em>]</em>) – The system structure represented by a tuple with the local
dimension of the constituent subsystems.</p></li>
<li><p><strong>permutation</strong> (<em>tuple</em><em>[</em><em>int</em><em>]</em>) – The permutation that maps i to permutation[i].</p></li>
<li><p><strong>inverse</strong> (<em>bool</em>) – Whether to perform the inverse of the permutation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The density matrix of the state after applying the permutation.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the system and permutation are incompatible.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.state_transformations.subsystem_reshape">
<span class="sig-prename descclassname"><span class="pre">pyqch.state_transformations.</span></span><span class="sig-name descname"><span class="pre">subsystem_reshape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#pyqch.state_transformations.subsystem_reshape" title="Link to this definition"></a></dt>
<dd><p>Reshapes the density matrix to the given system structure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> (<em>np.ndarray</em>) – The density matrix to be reshaped.</p></li>
<li><p><strong>system</strong> (<em>tuple</em><em>[</em><em>int</em><em>]</em>) – The system structure represented by a tuple with the local
dimension of the constituent subsystems.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The reshaped density matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If state and system are not compatible.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyqch.state_transformations.twirling">
<span class="sig-prename descclassname"><span class="pre">pyqch.state_transformations.</span></span><span class="sig-name descname"><span class="pre">twirling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decomposition</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyqch.state_transformations.twirling" title="Link to this definition"></a></dt>
<dd></dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="modules.html" class="btn btn-neutral float-left" title="pyqch" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Ruben Ibarrondo.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>